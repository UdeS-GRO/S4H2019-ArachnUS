% invCinPatte - ArachnUS - Cinématique de Patte
% Fonction qui retourne la position angulaire de la représentation de la
% patte à partir d'une position cartésienne
% Création : 13 Mars 2019 - 11h
% Dernière Modification : 13 Mars 2019 - 11h

function IK = invCinPatte(Pgoal, q, Tw0)
    Pcurr = fk_4_ik(q,Tw0)
    IK = 1;
    
    Rgoal=EulerXYZtoRot(Pgoal(4:6));        %Goal rotation matrix
    ii = 1;
    Err = abs(Pgoal-Pcurr);                 %Error between Pgoal and Pcurr
    
    while max(Err)>0.001                    %Beginning of the iterative method
%     for ii=1:1000                         %Uncomment line if you prefer a number of iterations rather than an error to respect
        Pcurr_old = Pcurr;
        Rcurr=EulerXYZtoRot(Pcurr(4:6));    %Current rotational matrix from Euler angles
        delta_R=Rgoal-Rcurr;                %Difference between matrices
        Omega=delta_R/Rcurr;                %matrix differential rule: delta_R=Omega*Rcurr. So Omega = delta_R*inv(Rcurr)

        dX(4,:)=(Omega(3,2)-Omega(2,3))/2;  %Finding wx from W
        dX(5,:)=(Omega(1,3)-Omega(3,1))/2;  %Finding wy from W
        dX(6,:)=(Omega(2,1)-Omega(1,2))/2;  %Finding wz from W

        dX(1:3,:) = Pgoal(1:3)-Pcurr(1:3);  %positional displacement as seen in the class notes
        J = Jacobian_complete(convention, DOF, DH, TW0,q, angleUnit);   %Determination of the Jacobian at angle q
        dTheta = J\dX;                      %Inverse Kinematics formula
        q = q + dTheta;                     %Finding new angles
        Pcurr = FKforIK(convention, DOF, DH, TW0, q, angleUnit); %Determining new Pcurr from new q
        Err = abs(Pcurr_old-Pcurr);         %Determining Err from new Pcurr
        ii = ii+1;
        
    end
end